name: Build and Release

permissions:
  contents: write

on:
  schedule:
    # Run daily at 08:00 UTC
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - prerelease
      force_build:
        description: 'Force build even if no data changes?'
        required: false
        default: false
        type: boolean
      publish:
        description: 'Publish to third-party platforms?'
        required: false
        default: true
        type: boolean

jobs:
  check-and-build:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_changes.outputs.should_build }}
      new_version: ${{ steps.version.outputs.new_version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ssh-key: ${{ secrets.DEPLOY_TOKEN }}
          persist-credentials: true

      - name: Check for data directory changes
        id: check_changes
        run: |
          # Check if version.txt exists and get the commit where it was last modified
          if [ -f "info/version.txt" ]; then
            LAST_BUILD_COMMIT=$(git log -1 --format=%H -- info/version.txt 2>/dev/null || echo "")
            echo "Last build commit: $LAST_BUILD_COMMIT"
          else
            LAST_BUILD_COMMIT=""
            echo "No version.txt found, this is the first build"
          fi
          
          if [ -z "$LAST_BUILD_COMMIT" ]; then
            echo "No previous build found, will build"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            # Check if data directory has changed since last version.txt update
            CHANGES=$(git diff --name-only "$LAST_BUILD_COMMIT" HEAD -- data/ 2>/dev/null || echo "")
            if [ -n "$CHANGES" ]; then
              echo "Data directory has changes since last build:"
              echo "$CHANGES"
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "No changes in data directory since last build"
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Override if force_build is true
          if [ "${{ github.event.inputs.force_build }}" = "true" ]; then
            echo "Force build enabled"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate version number
        id: version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Generate semantic version: year.month.patch
          YEAR=$(date +%Y)
          MONTH=$(date +%m)
          MONTH=${MONTH#0}  # Remove leading zero for portability
          
          # Read current version from version.txt
          if [ -f "info/version.txt" ]; then
            CURRENT_VERSION=$(cat info/version.txt)
            echo "Current version: $CURRENT_VERSION"
            
            # Extract year, month, patch from current version
            CURRENT_YEAR=$(echo $CURRENT_VERSION | cut -d. -f1)
            CURRENT_MONTH=$(echo $CURRENT_VERSION | cut -d. -f2)
            CURRENT_PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
            
            # If year or month changed, reset patch to 0, otherwise increment
            if [ "$YEAR" != "$CURRENT_YEAR" ] || [ "$MONTH" != "$CURRENT_MONTH" ]; then
              PATCH=0
            else
              PATCH=$((CURRENT_PATCH + 1))
            fi
          else
            # First version
            PATCH=0
          fi
          
          NEW_VERSION="${YEAR}.${MONTH}.${PATCH}"
          echo "=========================================="
          echo "Building Version: $NEW_VERSION"
          echo "=========================================="
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Update version.txt
          echo "$NEW_VERSION" > info/version.txt

      - name: Set up Python
        if: steps.check_changes.outputs.should_build == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Install Python dependencies
          pip install -r .github/scripts/requirements.txt
          # Ensure jq is installed (check first to avoid unnecessary updates)
          if ! command -v jq &> /dev/null; then
            echo "jq not found, installing..."
            sudo apt-get update && sudo apt-get install -y jq
          else
            echo "jq is already installed"
          fi

      - name: Convert TOML to CSV
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          echo "=========================================="
          echo "Converting TOML to CSV - Version: $NEW_VERSION"
          echo "=========================================="
          
          # Create mod directory structure
          mkdir -p mod/Localizations
          
          # Define log file path and store in environment for later steps
          LOG_FILE="python_conversion.log"
          echo "PYTHON_LOG_FILE=$LOG_FILE" >> $GITHUB_ENV
          
          # Run conversion script and capture output
          python3 .github/scripts/convert_toml_to_csv.py data mod 2>&1 | tee "$LOG_FILE"
          
          echo "TOML to CSV conversion completed"

      - name: Update manifest version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Update manifest.json with new version using jq for safer JSON manipulation
          if [ -f "info/manifest.json" ]; then
            # Use jq to safely update the Version field
            TMP_FILE=$(mktemp)
            jq --arg version "$NEW_VERSION" '.Version = $version' info/manifest.json > "$TMP_FILE"
            if [ $? -eq 0 ]; then
              mv "$TMP_FILE" info/manifest.json
              echo "Updated manifest.json to version $NEW_VERSION"
            else
              echo "Error: Failed to update manifest.json"
              rm -f "$TMP_FILE"
              exit 1
            fi
          fi

      - name: Create release package
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          RELEASE_DIR="Timberborn_Mods_Universal_Translate"
          
          # Create release directory
          mkdir -p "$RELEASE_DIR"
          
          # Copy mod files
          if [ -d "mod" ] && [ "$(ls -A mod)" ]; then
            cp -r mod/* "$RELEASE_DIR"/
          fi
          
          # Copy info files (but not version.txt)
          cp info/thumbnail.png "$RELEASE_DIR"/
          cp info/manifest.json "$RELEASE_DIR"/
          cp info/License.txt "$RELEASE_DIR"/
          
          # Copy workshop_data.json if it exists
          if [ -f "info/workshop_data.json" ]; then
            cp info/workshop_data.json "$RELEASE_DIR"/
          fi
          
          # Create zip file with versioned name for GitHub release
          zip -r "${NEW_VERSION}.zip" "$RELEASE_DIR"
          
          # Save package to repository releases directory with fixed name
          mkdir -p releases
          # Remove all old release files to keep only the newest
          rm -f releases/*.zip
          # Save with fixed name 'newest.zip'
          cp "${NEW_VERSION}.zip" "releases/newest.zip"
          
          echo "Release package created: ${NEW_VERSION}.zip"
          echo "Package saved to releases/newest.zip (fixed name)"

      - name: Create GitHub Release
        if: steps.check_changes.outputs.should_build == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          GIT_TAG="v${NEW_VERSION}"

          # Determine if this is a prerelease (only for manual dispatch, schedule is always release)
          IS_PRERELEASE="false"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.release_type }}" = "prerelease" ]; then
            IS_PRERELEASE="true"
          fi

          # Prepare release notes file (simpler and YAML-safe)
          RELEASE_NOTES_FILE="release_notes.md"
          
          # Get last build commit for comparison
          if [ -f "info/version.txt" ]; then
            LAST_BUILD_COMMIT=$(git log -1 --format=%H -- info/version.txt~1 2>/dev/null || echo "")
          else
            LAST_BUILD_COMMIT=""
          fi
          
          # Create changelog header
          echo "# Release $NEW_VERSION" > "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          echo "Automated update with new mod translations and data changes." >> "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          
          # Generate changelog
          echo "## ðŸ“ Changelog" >> "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          
          if [ -n "$LAST_BUILD_COMMIT" ]; then
            # Get changes since last build
            ADDED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^A" | wc -l)
            MODIFIED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^M" | wc -l)
            DELETED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^D" | wc -l)
            
            echo "### ðŸ“Š Data Changes" >> "$RELEASE_NOTES_FILE"
            echo "- ðŸ“„ **$ADDED_FILES** new mod entries added" >> "$RELEASE_NOTES_FILE"
            echo "- âœï¸ **$MODIFIED_FILES** mod entries updated" >> "$RELEASE_NOTES_FILE"
            if [ "$DELETED_FILES" -gt 0 ]; then
              echo "- ðŸ—‘ï¸ **$DELETED_FILES** mod entries removed" >> "$RELEASE_NOTES_FILE"
            fi
            echo >> "$RELEASE_NOTES_FILE"
            
            # Get previous version tag for comparison
            PREV_TAG=$(git tag --sort=-version:refname | head -2 | tail -1 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...v${NEW_VERSION}" >> "$RELEASE_NOTES_FILE"
            else
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/v${NEW_VERSION}" >> "$RELEASE_NOTES_FILE"
            fi
            echo >> "$RELEASE_NOTES_FILE"
            
            # Show total mod count
            TOTAL_MODS=$(find data/ -name "*.toml" -type f | wc -l)
            echo "### ðŸ“ˆ Statistics" >> "$RELEASE_NOTES_FILE"
            echo "- ðŸŽ¯ **$TOTAL_MODS** total mods in database" >> "$RELEASE_NOTES_FILE"
            echo "- ðŸ“… Built on $(date '+%Y-%m-%d %H:%M:%S UTC')" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
          else
            echo "### ðŸŽ‰ Initial Release" >> "$RELEASE_NOTES_FILE"
            TOTAL_MODS=$(find data/ -name "*.toml" -type f | wc -l)
            echo "- ðŸŽ¯ **$TOTAL_MODS** mods included in initial release" >> "$RELEASE_NOTES_FILE"
            echo "- ðŸ“… Built on $(date '+%Y-%m-%d %H:%M:%S UTC')" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
          fi

          # Append build log if available
          if [ -n "${PYTHON_LOG_FILE:-}" ] && [ -f "$PYTHON_LOG_FILE" ]; then
            echo "## ðŸ”§ Build Details" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
            echo "<details>" >> "$RELEASE_NOTES_FILE"
            echo "<summary>ðŸ“‹ View Build Log</summary>" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
            echo '```log' >> "$RELEASE_NOTES_FILE"
            cat "$PYTHON_LOG_FILE" >> "$RELEASE_NOTES_FILE"
            echo '```' >> "$RELEASE_NOTES_FILE"
            echo "</details>" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
          fi
          
          # Add footer
          echo "---" >> "$RELEASE_NOTES_FILE"
          echo "*This release was automatically generated by GitHub Actions*" >> "$RELEASE_NOTES_FILE"

          # Create GitHub release
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG" \
              --notes-file "$RELEASE_NOTES_FILE" \
              --prerelease \
              "${NEW_VERSION}.zip"
          else
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG" \
              --notes-file "$RELEASE_NOTES_FILE" \
              "${NEW_VERSION}.zip"
          fi

          echo "GitHub Release $GIT_TAG created"

      - name: Commit version update
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add info/version.txt info/manifest.json releases/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update version to ${{ steps.version.outputs.new_version }} and add release package"
            
            # Push with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push; then
                echo "Successfully pushed changes"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                  sleep 2
                else
                  echo "Error: Failed to push changes after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

  publish:
    needs: check-and-build
    if: needs.check-and-build.outputs.should_build == 'true' && (github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type != 'prerelease' && github.event.inputs.publish == 'true'))
    uses: ./.github/workflows/publish.yml
    secrets: inherit
