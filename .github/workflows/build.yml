name: Build and Release

permissions:
  contents: write

on:
  schedule:
    # Run daily at 08:00 UTC
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force build even if no data changes?'
        required: false
        default: false
        type: boolean

jobs:
  check-and-build:
    if: github.event_name == 'schedule' || contains(fromJSON(vars.WORKFLOWS_ALLOWLIST || '[]'), github.actor)
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_changes.outputs.should_build }}
      new_version: ${{ steps.version.outputs.new_version }}
      has_errors: ${{ steps.check_errors.outputs.has_errors }}
      publish_enabled: ${{ steps.check_errors.outputs.publish_enabled }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ssh-key: ${{ secrets.DEPLOY_TOKEN }}
          persist-credentials: true

      - name: Check for data directory changes
        id: check_changes
        run: |
          # Check if version.txt exists and get the commit where it was last modified
          if [ -f ".github/data/version.txt" ]; then
            LAST_BUILD_COMMIT=$(git log -1 --format=%H -- .github/data/version.txt 2>/dev/null || echo "")
            echo "Last build commit: $LAST_BUILD_COMMIT"
          else
            LAST_BUILD_COMMIT=""
            echo "No version.txt found, this is the first build"
          fi
          
          if [ -z "$LAST_BUILD_COMMIT" ]; then
            echo "No previous build found, will build"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            # Check if data directory has changed since last version.txt update
            CHANGES=$(git diff --name-only "$LAST_BUILD_COMMIT" HEAD -- data/ 2>/dev/null || echo "")
            if [ -n "$CHANGES" ]; then
              echo "Data directory has changes since last build:"
              echo "$CHANGES"
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "No changes in data directory since last build"
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Override if force_build is true
          if [ "${{ github.event.inputs.force_build }}" = "true" ]; then
            echo "Force build enabled"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate version number
        id: version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Generate semantic version: year.month.dpatch (where d=day without leading zero, patch=1-9 daily release count)
          YEAR=$(date +%Y)
          MONTH=$(date +%m)
          MONTH=${MONTH#0}  # Remove leading zero for portability
          DAY=$(date +%d)
          DAY=${DAY#0}  # Remove leading zero for portability
          
          # Read current version from version.txt
          if [ -f ".github/data/version.txt" ]; then
            CURRENT_VERSION=$(cat .github/data/version.txt)
            echo "Current version: $CURRENT_VERSION"
            
            # Extract year, month, dpatch from current version
            CURRENT_YEAR=$(echo $CURRENT_VERSION | cut -d. -f1)
            CURRENT_MONTH=$(echo $CURRENT_VERSION | cut -d. -f2)
            CURRENT_DPATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
            
            # Extract day and patch from dpatch (format: dp or ddp where d/dd=day, p=patch 0-9)
            # Since patch is always single digit (0-9), we take last character as patch
            CURRENT_PATCH_NUM=${CURRENT_DPATCH: -1}
            CURRENT_DAY=${CURRENT_DPATCH%?}  # Remove last character to get day part
            
            # Convert to numbers for comparison
            CURRENT_DAY=$((CURRENT_DAY))
            CURRENT_PATCH_NUM=$((CURRENT_PATCH_NUM))
            
            # If year, month, or day changed, reset patch to 0, otherwise increment
            if [ "$YEAR" != "$CURRENT_YEAR" ] || [ "$MONTH" != "$CURRENT_MONTH" ] || [ "$DAY" != "$CURRENT_DAY" ]; then
              PATCH_NUM=0
            else
              PATCH_NUM=$((CURRENT_PATCH_NUM + 1))
              # Ensure patch number stays within 0-9
              if [ $PATCH_NUM -gt 9 ]; then
                echo "Warning: Daily patch limit (9) reached, resetting to 9"
                PATCH_NUM=9
              fi
            fi
          else
            # First version
            PATCH_NUM=0
          fi
          
          # Combine day (without leading zero) and patch number
          DPATCH="${DAY}${PATCH_NUM}"
          
          NEW_VERSION="${YEAR}.${MONTH}.${DPATCH}"
          echo "=========================================="
          echo "Building Version: $NEW_VERSION"
          echo "=========================================="
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Update version.txt
          echo "$NEW_VERSION" > .github/data/version.txt

      - name: Set up Python
        if: steps.check_changes.outputs.should_build == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Install Python dependencies
          pip install -r .github/scripts/requirements.txt
          # Ensure jq is installed (check first to avoid unnecessary updates)
          if ! command -v jq &> /dev/null; then
            echo "jq not found, installing..."
            sudo apt-get update && sudo apt-get install -y jq
          else
            echo "jq is already installed"
          fi

      - name: Convert TOML to CSV
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          echo "=========================================="
          echo "Converting TOML to CSV - Version: $NEW_VERSION"
          echo "=========================================="
          
          # Create mod directory structure
          mkdir -p mod/Localizations
          
          # Run conversion script - Python will handle logging
          CONVERSION_OUTPUT=$(python3 .github/scripts/convert_toml_to_csv.py data mod 2>&1)
          echo "$CONVERSION_OUTPUT"
          
          # Extract warnings/errors file path from Python output
          WARNINGS_ERRORS_FILE=$(echo "$CONVERSION_OUTPUT" | grep "WARNINGS_ERRORS_FILE=" | cut -d'=' -f2)
          if [ -n "$WARNINGS_ERRORS_FILE" ]; then
            echo "PYTHON_LOG_FILE=$WARNINGS_ERRORS_FILE" >> $GITHUB_ENV
            echo "Warnings/errors logged to: $WARNINGS_ERRORS_FILE"
            
            # Show summary if file has content
            if [ -f "$WARNINGS_ERRORS_FILE" ] && [ -s "$WARNINGS_ERRORS_FILE" ]; then
              ISSUES_COUNT=$(wc -l < "$WARNINGS_ERRORS_FILE")
              echo "Found $ISSUES_COUNT warnings/errors for release notes"
            else
              echo "No warnings or errors found"
            fi
          else
            echo "Warning: Could not determine warnings/errors file path"
          fi
          
          echo "=========================================="
          echo "TOML to CSV conversion completed"

      - name: Update manifest version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Update manifest.json with new version using jq for safer JSON manipulation
          if [ -f ".github/data/manifest.json" ]; then
            # Ensure manifest.json is valid JSON before updating
            if jq -e . .github/data/manifest.json > /dev/null 2>&1; then
              # Use jq to safely update the Version field without losing other content
              TMP_FILE=$(mktemp)
              if [ $? -eq 0 ]; then
                if jq --arg ver "$NEW_VERSION" '.Version = $ver' .github/data/manifest.json > "$TMP_FILE"; then
                  mv "$TMP_FILE" .github/data/manifest.json
                  echo "Updated manifest.json to version $NEW_VERSION"
                else
                  echo "Error: jq failed to update manifest.json"
                  rm -f "$TMP_FILE"
                  exit 1
                fi
              else
                echo "Error: Failed to create temporary file"
                exit 1
              fi
            else
              echo "Warning: .github/data/manifest.json is invalid or empty JSON; skipping version update to avoid data loss"
            fi
          fi

      - name: Create release package
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          RELEASE_DIR="Timberborn_Mods_Universal_Translate"
          
          # Create release directory
          mkdir -p "$RELEASE_DIR"
          
          # Copy mod files
          if [ -d "mod" ] && [ "$(ls -A mod)" ]; then
            cp -r mod/* "$RELEASE_DIR"/
          fi
          
          # Copy info files (but not version.txt)
          cp .github/data/thumbnail.png "$RELEASE_DIR"/
          cp .github/data/manifest.json "$RELEASE_DIR"/
          cp License.txt "$RELEASE_DIR"/
          
          # Copy workshop_data.json if it exists
          if [ -f ".github/data/workshop_data.json" ]; then
            cp .github/data/workshop_data.json "$RELEASE_DIR"/
          fi
          
          # Copy lang_describe files (preserved non-native support text description files)
          if [ -d ".github/data/lang_describe" ] && [ "$(ls -A .github/data/lang_describe 2>/dev/null)" ]; then
            echo "Copying lang_describe files to release package..."
            # Create Localizations directory if it doesn't exist
            mkdir -p "$RELEASE_DIR/Localizations"
            # Copy all files from lang_describe directory, overwriting any existing files
            cp -f .github/data/lang_describe/* "$RELEASE_DIR/Localizations/"
            echo "lang_describe files copied successfully"
          else
            echo "No lang_describe files found to copy"
          fi
          
          # Create zip file with versioned name for GitHub release
          zip -r "${NEW_VERSION}.zip" "$RELEASE_DIR"
          
          echo "Release package created: ${NEW_VERSION}.zip"

      - name: Prepare release notes
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Prepare release notes file (simpler and YAML-safe)
          RELEASE_NOTES_FILE="release_notes.md"
          
          # Get last build commit for comparison
          if [ -f ".github/data/version.txt" ]; then
            # Get the commit where version.txt was last modified (before current changes)
            LAST_BUILD_COMMIT=$(git log --skip=1 -1 --format=%H -- .github/data/version.txt 2>/dev/null || echo "")
            echo "Last build commit: $LAST_BUILD_COMMIT"
          else
            LAST_BUILD_COMMIT=""
            echo "No version.txt found, this is the first build"
          fi
          
          # Create changelog header
          echo "# Release $NEW_VERSION" > "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          echo "Automated update with new mod translations and data changes." >> "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          
          # Generate changelog
          echo "## üìù Changelog" >> "$RELEASE_NOTES_FILE"
          echo >> "$RELEASE_NOTES_FILE"
          
          if [ -n "$LAST_BUILD_COMMIT" ]; then
            # Get changes since last build
            ADDED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^A" | wc -l)
            MODIFIED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^M" | wc -l)
            DELETED_FILES=$(git diff --name-status "$LAST_BUILD_COMMIT" HEAD -- data/ | grep "^D" | wc -l)
            
            echo "### üìä Data Changes" >> "$RELEASE_NOTES_FILE"
            echo "- üìÑ **$ADDED_FILES** new mod entries added" >> "$RELEASE_NOTES_FILE"
            echo "- ‚úèÔ∏è **$MODIFIED_FILES** mod entries updated" >> "$RELEASE_NOTES_FILE"
            if [ "$DELETED_FILES" -gt 0 ]; then
              echo "- üóëÔ∏è **$DELETED_FILES** mod entries removed" >> "$RELEASE_NOTES_FILE"
            fi
            echo >> "$RELEASE_NOTES_FILE"
            
            # Show total mod count
            TOTAL_MODS=$(find data/ -name "*.toml" -type f | wc -l)
            echo "### üìà Statistics" >> "$RELEASE_NOTES_FILE"
            echo "- üéØ **$TOTAL_MODS** total mods in database" >> "$RELEASE_NOTES_FILE"
            echo "- üìÖ Built on $(date '+%Y-%m-%d %H:%M:%S UTC')" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
          else
            echo "### üéâ Initial Release" >> "$RELEASE_NOTES_FILE"
            TOTAL_MODS=$(find data/ -name "*.toml" -type f | wc -l)
            echo "- üéØ **$TOTAL_MODS** mods included in initial release" >> "$RELEASE_NOTES_FILE"
            echo "- üìÖ Built on $(date '+%Y-%m-%d %H:%M:%S UTC')" >> "$RELEASE_NOTES_FILE"
            echo >> "$RELEASE_NOTES_FILE"
          fi

          # Append filtered build log (warnings and errors only) if available
          if [ -n "${PYTHON_LOG_FILE:-}" ] && [ -f "$PYTHON_LOG_FILE" ]; then
            # Check if there are any warnings or errors to include
            if [ -s "$PYTHON_LOG_FILE" ] && [ "$(cat "$PYTHON_LOG_FILE")" != "No warnings or errors found during conversion" ]; then
              echo "## ‚ö†Ô∏è Build Issues" >> "$RELEASE_NOTES_FILE"
              echo >> "$RELEASE_NOTES_FILE"
              echo "The following warnings and errors were found during conversion:" >> "$RELEASE_NOTES_FILE"
              echo >> "$RELEASE_NOTES_FILE"
              echo "<details>" >> "$RELEASE_NOTES_FILE"
              echo "<summary>üìã View Issues</summary>" >> "$RELEASE_NOTES_FILE"
              echo >> "$RELEASE_NOTES_FILE"
              echo '```log' >> "$RELEASE_NOTES_FILE"
              cat "$PYTHON_LOG_FILE" >> "$RELEASE_NOTES_FILE"
              echo '```' >> "$RELEASE_NOTES_FILE"
              echo "</details>" >> "$RELEASE_NOTES_FILE"
              echo >> "$RELEASE_NOTES_FILE"
            fi
          fi
          
          # Save changelog to .github/log/changelog.md for other platforms
          mkdir -p .github/log
          cp "$RELEASE_NOTES_FILE" ".github/log/changelog.md"
          
          echo "Changelog saved to: .github/log/changelog.md"

      - name: Check for build errors
        if: steps.check_changes.outputs.should_build == 'true'
        id: check_errors
        run: |
          HAS_ERRORS="false"
          PUBLISH_ENABLED="true"
          
          # Check if Python log file exists and has content indicating errors
          if [ -n "${PYTHON_LOG_FILE:-}" ] && [ -f "$PYTHON_LOG_FILE" ]; then
            # Check if the log contains actual errors (not just the "No warnings or errors" message)
            if [ -s "$PYTHON_LOG_FILE" ] && [ "$(cat "$PYTHON_LOG_FILE")" != "No warnings or errors found during conversion" ]; then
              # Check for ERROR keyword in the log
              if grep -qi "error" "$PYTHON_LOG_FILE"; then
                HAS_ERRORS="true"
                PUBLISH_ENABLED="false"
                echo "=========================================="
                echo "‚ö†Ô∏è  ERRORS DETECTED IN BUILD"
                echo "=========================================="
                echo "Build contains errors. This release will be:"
                echo "  - Marked as prerelease"
                echo "  - Third-party platform publishing will be disabled"
                echo ""
                echo "Error details can be found in the release notes."
                echo "=========================================="
              fi
            fi
          fi
          
          echo "has_errors=$HAS_ERRORS" >> $GITHUB_OUTPUT
          echo "publish_enabled=$PUBLISH_ENABLED" >> $GITHUB_OUTPUT
          
          if [ "$HAS_ERRORS" = "true" ]; then
            echo "‚ö†Ô∏è  Build completed with errors - will create prerelease"
          else
            echo "‚úì Build completed successfully - will create full release"
          fi

      - name: Commit version update
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add .github/data/version.txt .github/data/manifest.json .github/log/changelog.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update version to ${{ steps.version.outputs.new_version }}"
            
            # Push with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push; then
                echo "Successfully pushed changes"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                  sleep 2
                else
                  echo "Error: Failed to push changes after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

      - name: Create GitHub Release
        if: steps.check_changes.outputs.should_build == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          GIT_TAG="v${NEW_VERSION}"
          HAS_ERRORS="${{ steps.check_errors.outputs.has_errors }}"

          # Automatically determine if this is a prerelease based on error detection
          IS_PRERELEASE="false"
          if [ "$HAS_ERRORS" = "true" ]; then
            IS_PRERELEASE="true"
            echo "‚ö†Ô∏è  Creating as PRERELEASE due to detected errors"
          else
            echo "‚úì Creating as full RELEASE"
          fi

          # Update changelog with proper links now that we have the final commit
          RELEASE_NOTES_FILE="release_notes.md"
          
          # Get previous version tag for comparison (now we can do this correctly)
          PREV_TAG=$(git tag --list --sort=-version:refname "v*" | head -1 2>/dev/null || echo "")
          echo "Previous tag: $PREV_TAG"
          
          # Add full changelog link to the notes
          if [ -n "$PREV_TAG" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...v${NEW_VERSION}" >> "$RELEASE_NOTES_FILE"
          else
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/v${NEW_VERSION}" >> "$RELEASE_NOTES_FILE"
          fi
          
          # Add error notice to release notes if errors were detected
          if [ "$IS_PRERELEASE" = "true" ]; then
            sed -i '1s/^/---\n**‚ö†Ô∏è  PRERELEASE**: This release contains build errors and is marked as prerelease. Third-party platform publishing has been disabled.\n---\n\n/' "$RELEASE_NOTES_FILE"
          fi

          # Create GitHub release
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG (Prerelease)" \
              --notes-file "$RELEASE_NOTES_FILE" \
              --prerelease \
              "${NEW_VERSION}.zip"
          else
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG" \
              --notes-file "$RELEASE_NOTES_FILE" \
              "${NEW_VERSION}.zip"
          fi

          echo "GitHub Release $GIT_TAG created"

  publish:
    needs: check-and-build
    # Publish to third-party platforms only if:
    # 1. Build was successful (should_build == true)
    # 2. No errors were detected (publish_enabled == true)
    if: needs.check-and-build.outputs.should_build == 'true' && needs.check-and-build.outputs.publish_enabled == 'true'
    uses: ./.github/workflows/publish.yml
    secrets: inherit
