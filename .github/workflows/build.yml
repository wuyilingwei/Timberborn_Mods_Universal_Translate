name: Build and Release

permissions:
  contents: write

on:
  schedule:
    # Run daily at 08:00 UTC
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - prerelease
      force_build:
        description: 'Force build even if no data changes?'
        required: false
        default: false
        type: boolean
      publish:
        description: 'Publish to third-party platforms?'
        required: false
        default: true
        type: boolean

jobs:
  check-and-build:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_changes.outputs.should_build }}
      new_version: ${{ steps.version.outputs.new_version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for data directory changes
        id: check_changes
        run: |
          # Check if version.txt exists and get the commit where it was last modified
          if [ -f "info/version.txt" ]; then
            LAST_BUILD_COMMIT=$(git log -1 --format=%H -- info/version.txt 2>/dev/null || echo "")
            echo "Last build commit: $LAST_BUILD_COMMIT"
          else
            LAST_BUILD_COMMIT=""
            echo "No version.txt found, this is the first build"
          fi
          
          if [ -z "$LAST_BUILD_COMMIT" ]; then
            echo "No previous build found, will build"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            # Check if data directory has changed since last version.txt update
            CHANGES=$(git diff --name-only "$LAST_BUILD_COMMIT" HEAD -- data/ 2>/dev/null || echo "")
            if [ -n "$CHANGES" ]; then
              echo "Data directory has changes since last build:"
              echo "$CHANGES"
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "No changes in data directory since last build"
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Override if force_build is true
          if [ "${{ github.event.inputs.force_build }}" = "true" ]; then
            echo "Force build enabled"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate version number
        id: version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Generate semantic version: year.month.patch
          YEAR=$(date +%Y)
          MONTH=$(date +%m)
          MONTH=${MONTH#0}  # Remove leading zero for portability
          
          # Read current version from version.txt
          if [ -f "info/version.txt" ]; then
            CURRENT_VERSION=$(cat info/version.txt)
            echo "Current version: $CURRENT_VERSION"
            
            # Extract year, month, patch from current version
            CURRENT_YEAR=$(echo $CURRENT_VERSION | cut -d. -f1)
            CURRENT_MONTH=$(echo $CURRENT_VERSION | cut -d. -f2)
            CURRENT_PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
            
            # If year or month changed, reset patch to 0, otherwise increment
            if [ "$YEAR" != "$CURRENT_YEAR" ] || [ "$MONTH" != "$CURRENT_MONTH" ]; then
              PATCH=0
            else
              PATCH=$((CURRENT_PATCH + 1))
            fi
          else
            # First version
            PATCH=0
          fi
          
          NEW_VERSION="${YEAR}.${MONTH}.${PATCH}"
          echo "=========================================="
          echo "Building Version: $NEW_VERSION"
          echo "=========================================="
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Update version.txt
          echo "$NEW_VERSION" > info/version.txt

      - name: Set up Python
        if: steps.check_changes.outputs.should_build == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          # Install Python dependencies
          pip install -r .github/scripts/requirements.txt
          # Ensure jq is installed (check first to avoid unnecessary updates)
          if ! command -v jq &> /dev/null; then
            echo "jq not found, installing..."
            sudo apt-get update && sudo apt-get install -y jq
          else
            echo "jq is already installed"
          fi

      - name: Convert TOML to CSV
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          echo "=========================================="
          echo "Converting TOML to CSV - Version: $NEW_VERSION"
          echo "=========================================="
          
          # Create mod directory structure
          mkdir -p mod/Localizations
          
          # Define log file path and store in environment for later steps
          LOG_FILE="python_conversion.log"
          echo "PYTHON_LOG_FILE=$LOG_FILE" >> $GITHUB_ENV
          
          # Run conversion script and capture output
          python3 .github/scripts/convert_toml_to_csv.py data mod 2>&1 | tee "$LOG_FILE"
          
          echo "TOML to CSV conversion completed"

      - name: Update manifest version
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Update manifest.json with new version using jq for safer JSON manipulation
          if [ -f "info/manifest.json" ]; then
            # Use jq to safely update the Version field
            TMP_FILE=$(mktemp)
            jq --arg version "$NEW_VERSION" '.Version = $version' info/manifest.json > "$TMP_FILE"
            if [ $? -eq 0 ]; then
              mv "$TMP_FILE" info/manifest.json
              echo "Updated manifest.json to version $NEW_VERSION"
            else
              echo "Error: Failed to update manifest.json"
              rm -f "$TMP_FILE"
              exit 1
            fi
          fi

      - name: Create release package
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          RELEASE_DIR="Timberborn_Mods_Universal_Translate"
          
          # Create release directory
          mkdir -p "$RELEASE_DIR"
          
          # Copy mod files
          if [ -d "mod" ] && [ "$(ls -A mod)" ]; then
            cp -r mod/* "$RELEASE_DIR"/
          fi
          
          # Copy info files (but not version.txt)
          cp info/thumbnail.png "$RELEASE_DIR"/
          cp info/manifest.json "$RELEASE_DIR"/
          cp info/License.txt "$RELEASE_DIR"/
          
          # Copy workshop_data.json if it exists
          if [ -f "info/workshop_data.json" ]; then
            cp info/workshop_data.json "$RELEASE_DIR"/
          fi
          
          # Create zip file with versioned name for GitHub release
          zip -r "${NEW_VERSION}.zip" "$RELEASE_DIR"
          
          # Save package to repository releases directory with fixed name
          mkdir -p releases
          # Remove all old release files to keep only the newest
          rm -f releases/*.zip
          # Save with fixed name 'newest.zip'
          cp "${NEW_VERSION}.zip" "releases/newest.zip"
          
          echo "Release package created: ${NEW_VERSION}.zip"
          echo "Package saved to releases/newest.zip (fixed name)"

      - name: Create GitHub Release
        if: steps.check_changes.outputs.should_build == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          GIT_TAG="v${NEW_VERSION}"
          
          # Determine if this is a prerelease (only for manual dispatch, schedule is always release)
          IS_PRERELEASE="false"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.release_type }}" = "prerelease" ]; then
            IS_PRERELEASE="true"
          fi
          
          # Create release notes
          RELEASE_NOTES="Automated Update to $NEW_VERSION"
          
          # Add build log if available
          if [ -f "$PYTHON_LOG_FILE" ]; then
            echo "Processing build log..."
            
            # Check log file size (limit to 1000 lines for release notes)
            LOG_LINES=$(wc -l < "$PYTHON_LOG_FILE")
            MAX_LOG_LINES=1000
            
            if [ "$LOG_LINES" -gt "$MAX_LOG_LINES" ]; then
              echo "Warning: Log file is large ($LOG_LINES lines), truncating to last $MAX_LOG_LINES lines for release notes"
              # Use tail with line count to avoid breaking UTF-8 characters
              PYTHON_LOG_CONTENT=$(printf "... (log truncated, showing last %s lines)\n\n%s" "$MAX_LOG_LINES" "$(tail -n "$MAX_LOG_LINES" "$PYTHON_LOG_FILE")")
            else
              # Read the full log content
              PYTHON_LOG_CONTENT=$(cat "$PYTHON_LOG_FILE")
            fi
            
            # Extract error lines containing [ERROR] prefix (case-sensitive)
            # The Python script outputs errors in format: [ERROR] message
            # Only lines with the exact [ERROR] prefix are captured
            ERROR_LINES=$(grep "\[ERROR\]" "$PYTHON_LOG_FILE" 2>/dev/null)
            
            # Escape backticks in log content to prevent markdown code block issues
            PYTHON_LOG_CONTENT=$(echo "$PYTHON_LOG_CONTENT" | sed 's/`/\\`/g')
            if [ -n "$ERROR_LINES" ]; then
              ERROR_LINES=$(echo "$ERROR_LINES" | sed 's/`/\\`/g')
            fi
            
            if [ -n "$ERROR_LINES" ]; then
              # Create release notes with error log
              RELEASE_NOTES=$(cat <<EOF
          Automated Update to $NEW_VERSION
          
          <details>
          <summary>Build Log (Errors Occurred)</summary>
          
          **Error Messages:**
          \`\`\`
          $ERROR_LINES
          \`\`\`
          
          <details>
          <summary>Full Log</summary>
          
          \`\`\`
          $PYTHON_LOG_CONTENT
          \`\`\`
          </details>
          
          </details>
          EOF
          )
            else
              # Create release notes with success log
              RELEASE_NOTES=$(cat <<EOF
          Automated Update to $NEW_VERSION
          
          <details>
          <summary>Build Log</summary>
          
          No errors found during conversion.
          
          <details>
          <summary>Full Log</summary>
          
          \`\`\`
          $PYTHON_LOG_CONTENT
          \`\`\`
          </details>
          
          </details>
          EOF
          )
            fi
          fi
          
          # Create GitHub release
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG" \
              --notes "$RELEASE_NOTES" \
              --prerelease \
              "${NEW_VERSION}.zip"
          else
            gh release create "$GIT_TAG" \
              --repo "${{ github.repository }}" \
              --title "$GIT_TAG" \
              --notes "$RELEASE_NOTES" \
              "${NEW_VERSION}.zip"
          fi
          
          echo "GitHub Release $GIT_TAG created"
          
          # Clean up log file
          if [ -f "$PYTHON_LOG_FILE" ]; then
            echo "Cleaning up Python log file..."
            rm -f "$PYTHON_LOG_FILE"
          fi

      - name: Commit version update
        if: steps.check_changes.outputs.should_build == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add info/version.txt info/manifest.json releases/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update version to ${{ steps.version.outputs.new_version }} and add release package"
            
            # Push with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push; then
                echo "Successfully pushed changes"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                  sleep 2
                else
                  echo "Error: Failed to push changes after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

  publish:
    needs: check-and-build
    if: needs.check-and-build.outputs.should_build == 'true' && (github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type != 'prerelease' && github.event.inputs.publish == 'true'))
    uses: ./.github/workflows/publish.yml
    with:
      version: ${{ needs.check-and-build.outputs.new_version }}
    secrets: inherit
